services:
  # TRAEFIK
  traefik:
    image: "traefik:v2.9"
    container_name: "traefik_proxy"
    restart: always #se o container parar, o docker reinicializa automaticamente
    command:
      - "--api.insecure=true" #habilita o dashboard de administração do traefik
      - "--providers.docker=true" #habilita ao traefik observar mudanças no docker e criar rotas para elas automaticamente.
      - "--providers.docker.exposedbydefault=false" #medida de segurança para que o traefik só exponha os containers que tiverem a label "traefik.enable=true"
      - "--entrypoints.web.address=:80" #define a porta de escuta chamada web que fica na porta 80 do container do traefik
      - "--providers.docker.network=proxy-net" #informa a rede proxy-net para o traefik procurar os conatainers
    ports:
      #mapeia as portas da máquina --> container 
      - "8000:80" #prota da aplicação
      - "8080:8080" #porta do dashboard traefik 
    volumes:
      #monta pastas ou arquivos de volume de fora para dentro do container
      - "/var/run/docker.sock:/var/run/docker.sock:ro" # monta o socket do docker dentro do container do traefik para que ele consiga se comunicar com docker. "ro" --> read only
    networks:
      #conecta o serviço à rede proxy-net
      - proxy-net

  # APLICAÇÃO DE NOTÍCIAS (FLASK)
  news-service:
    build: ./news_service #constrói uma imagem nova do zero a partir do dockerfile contido na pasta ./news_service
    container_name: news_flask_service
    restart: always #se o container parar, o docker reinicializa automaticamente
    # O 'command' está no Dockerfile (Gunicorn)
    volumes:
      - ./news_service:/app #mapeia a pasta do codigo-fonte para dentro da pasta /app dentro do container. Possibilita o "hot-reload" --> reinicia o container quando vê uma mudança no código.
      - news_media_volume:/app/app/static/uploads #mapeia um volume para a pasta de uploads (guarda os arquivos mesmo que reinicie o container)
    expose:
      - 8000 #expõe a porta internamente, apenas para os serviços na mesma rede. 
    environment:
      #variáveis de ambiente
      # Variáveis Banco de Dados 
      - MYSQL_DATABASE=noticias_db
      - MYSQL_USER=noticias_user
      - MYSQL_PASSWORD=${NEWS_DB_PASSWORD}
      - MYSQL_HOST=news-db #conecta ao host news-db (nome do serviço do banco de dados)
      # Variáveis Flask
      - FLASK_APP=run.py
      - FLASK_DEBUG=1
      - SECRET_KEY=${FLASK_SECRET_KEY}
      # Variáveis Flask-Session (para conectar ao Redis)
      - SESSION_TYPE=redis
      - SESSION_REDIS=redis://redis-sessions:6379/0 #aponta para o serviço redis-sessions na porta 6379
    depends_on:
      #controla a ordem de inicialização 
      news-db:
        condition: service_healthy #só inicia o news_service quando o news-db estiver saudável (healthcheck).
      redis-sessions:
        condition: service_started #só inicia o news-service quando o redis tiver inicializado
    networks:
      - proxy-net #conecta o serviço à rede proxy-net
    labels:
      #etiquetas que o traefik lê
      # Roteamento Traefik 
      - "traefik.enable=true" #permite a exposição do container
      - "traefik.http.routers.news-router.rule=Host(`localhost`) && PathPrefix(`/noticias`)" #se o host for "localhost" E o caminho começar com "/noticias" -->
      - "traefik.http.routers.news-router.entrypoints=web" #no ponto de entrada web (porta 8000) -->
      - "traefik.http.routers.news-router.service=news-service" #envia o tráfego para o serviço traefik news-service
      - "traefik.http.services.news-service.loadbalancer.server.port=8000" #define o serviço traefik news-service (deve encaminhar o tráfego para a porta 8000 deste container)
      # Rota de mídia 
      - "traefik.http.routers.news-media-router.rule=Host (`localhost`) && PathPrefix(`/media`)" #mesma lógica de antes mas para o caminho /media (para que o traefik consiga servir arquivos estáticos de upload)
      - "traefik.http.routers.news-media-router.entrypoints=web"
      - "traefik.http.routers.news-media-router.service=news-service"

  # BANCO DE DADOS DO SERVIÇO NOTÍCIAS 
  news-db:
    image: mariadb:10.6
    container_name: noticias_mariadb
    restart: always #se o container parar, o docker reinicializa automaticamente
    environment:
      #variáveis de ambiente (quando o container sobe, o banco de dados com usuário e senha é construído automaticamente)
      MYSQL_DATABASE: 'noticias_db'
      MYSQL_USER: 'noticias_user'
      MYSQL_PASSWORD: ${NEWS_DB_PASSWORD}
      MYSQL_ROOT_PASSWORD: ${NEWS_ROOT_PASSWORD}
    volumes:
      - news_db_data:/var/lib/mysql #mapeia o volume nomeado news_db_data para a pasta interna do MariaDB (dados persistidos)
    healthcheck:
      #define como o docker deve verificar se o banco está saudável
      test: [ "CMD", "mysqladmin", "ping", "-h", "127.0.0.1", "-u", "noticias_user", "-pSophia866" ] #testes 
      interval: 10s #executa a verificação a cada 10 segundos
      timeout: 5s #falha se demorar mais que 5 segundos
      retries: 5 #tenta 5 vezes antes de marcar unealthy
    networks:
      - proxy-net #conecta o serviço à rede proxy-net

  # APLICAÇÃO DE USUÁRIOS (FLASK)
  users-service:
    #IGUAL O news-service SÓ MUDA AS VARIÁVEIS
    build: ./users_service #constrói uma imagem nova do zero a partir do dockerfile contido na pasta ./users_service
    container_name: users_flask_service
    restart: always #se o container parar, o docker reinicializa automaticamente
    # O 'command' está no Dockerfile
    volumes:
      - ./users_service:/app #mapeia a pasta do codigo-fonte para dentro da pasta /app dentro do container. Possibilita o "hot-reload" --> reinicia o container quando vê uma mudança no código.
    expose:
      - 8000 #expõe a porta internamente, apenas para os serviços na mesma rede. 
    environment:
      # Variáveis do Banco de Dados 
      - MYSQL_DATABASE=users_db
      - MYSQL_USER=users_user
      - MYSQL_PASSWORD= ${USERS_DB_PASSWORD}
      - MYSQL_HOST=users-db #conecta ao serviço users-db
      # Variáveis do Flask
      - FLASK_APP=run.py
      - FLASK_DEBUG=1
      - SECRET_KEY= ${FLASK_SECRET_KEY}
      # Variáveis do Flask-Session (para conectar ao Redis)
      - SESSION_TYPE=redis
      - SESSION_REDIS=redis://redis-sessions:6379/0 #aponta para o serviço redis-sessions na porta 6379
    depends_on:
      users-db:
        condition: service_healthy
      redis-sessions:
        condition: service_started
    networks:
      - proxy-net
    labels:
      # Roteamento do Traefik
      - "traefik.enable=true"
      - "traefik.http.routers.users-router.rule=Host(`localhost`) && PathPrefix(`/cadastro`)" #IGUAL, só muda p rota /cadastro
      - "traefik.http.routers.users-router.entrypoints=web"
      - "traefik.http.routers.users-router.service=users-service"
      - "traefik.http.services.users-service.loadbalancer.server.port=8000"

  # BANCO DE DADOS DE USUÁRIOS
  users-db:
    #IGUAL O news-db SÓ MUDA AS VARIÁVEIS
    image: mariadb:10.6
    container_name: users_mariadb
    restart: always
    environment:
      MYSQL_DATABASE: 'users_db'
      MYSQL_USER: 'users_user'
      MYSQL_PASSWORD: ${USERS_DB_PASSWORD}
      MYSQL_ROOT_PASSWORD: ${USERS_DB_PASSWORD}
    volumes:
      - users_db_data:/var/lib/mysql
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "127.0.0.1", "-u", "users_user", "-pOutraSenhaForte123" ]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - proxy-net

  # BANCO DE SESSÕES COMPARTILHADO
  redis-sessions:
    image: "redis:alpine"
    container_name: redis_sessions_db
    restart: always
    expose:
      - 6379 #expõe a porta padrão do redis 6379
    networks:
      - proxy-net

volumes:
  #decalra os volumes nomeados que utilizamos, Docker armazena eles em um local separado e os gerencia.
  news_db_data:
  news_media_volume:
  users_db_data:
  users_media_volume:
    # (não está sendo usado pq o users-service não contém uploads de arquivos estáticos)

networks:
  #definição da rede personalizada
  proxy-net:
    driver: bridge #tipo de rede (padrão bridge)
    name: proxy-net
    #todos os serviços conectados à essa rede podem se comunicar utilizando seus nomes de serviços como hostnames (Ex: news-service encontra o news-db no endereço http://news-db).
